## 렌더링과 리렌더링

- `useMemo`와 `useCallback`은 렌더에서 수행해야 하는 작업의 양을 줄이고, 컴포넌츠가 다시 렌더링해야하는 횟수를 줄이면서 **리렌더링 최척화**를 하게 됨
- 컴포넌트의 렌더링
  - 누군가가 함수(컴포넌트)를 호출해 실행되는 것
  - 함수가 실행될 때마다 내부에 선언되어 있던 표현식(변수, 또는 다른 함수 등)도 매번 다시 선언되어 사용됨
- 리렌더링
  - 리액트에서 초기에 한번 렌더링을 진행하고, 그 이후에 **특정 조건이 발생하면 다시 렌더링을 진행**하는 것

<br>

### 리액트에서 리렌더링이 일어나는 조건

1. 자신의 state가 변경이 될 때
2. 부모 컴포넌트로부터 전달받은 props가 변경될 때
3. 부모 컴포넌트가 리렌더링 될 때
4. `forceUpdate` 함수가 실행될 때

<br>

## 메모이제이션(Memoization)

- 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때 이전에 계산한 값을 메모리에 저장하는 것
- `useMemo`와 `useCallback`은 메모이제이션 기능을 제공하는 React의 내장 hook

<br>

즉, **동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술**이다.

<br>

## useMemo

- 계산 비용이 높은 함수의 **결과를 캐싱**해 **동일한 입력값에 대해서는 이전에 계산된 결과값을 반환**하면서 성능을 최적화하는 데 사용됨

- 리액트에서 함수형 컴포넌트의 렌더링 순서: <br>
  렌더링 -> 컴포넌트 함수 호출 -> <u>모든 내부 변수 초기화</u>
- `useMemo`를 사용했을 때의 렌더링 순서: <br>
  렌더링 -> 컴포넌트 함수 호출 -> <u>memoize된 함수 재사용</u>

<br>

`useMemo`를 사용하면 **동일한 값을 반환하는 함수를 반복적으로 호출해야하는 경우가 생길 때**, 처음 값을 계산할 때 해당 값을 메모리에 저장해 필요할 때마다 다시 계산하지 않고 **메모리에서 호출해 사용**할 수 있다.

<br>

### useMemo의 기본 구조

```js
const result = useMemo(콜백함수, [의존성 배열])
```

- 첫번째 인자: 콜백함수
  - 콜백함수의 결과값은 useMemo의 리턴값이 된다. (재사용하는 결과값)
- 두번째 인자: 의존성 배열
  - 의존성 배열의 전달 값이 변경될 때 콜백함수가 실행된다.
  <br>

> 💡 **기본적으로 useEffect와 비슷해보이는데.. 차이가 뭘까?**
> <br>
> `useMemo`와 `useEffect`는 비슷한 구조를 가지고 있지만, 가장 큰 차이점은 **렌더링 과정 중의 동작 여부**에 있다.
> <Br>
> `useEffect`는 **모든 렌더링이 완료된 이후에 실행**되며, 렌더링 후 상태가 업데이트 되었을 때를 감지하여 동작하기 때문에 **리렌더링을 방지하지 못한다**. 하지만 `useMemo`는 **렌더링 과정 중에 실행**되며, 의존성 배열 값이 변경되었는지를 확인해 값이 변경되었다면 이전에 저장한 값과 비교하여 **값이 다른 경우에만 리렌더링**을 해준다.

<br>

## useCallback

- `useMemo`와 비슷함
- 불필요한 리렌더링 방지를 위해 특정 함수를 새로 만들지 않고 재사용하고 싶을 때 사용함

<br>

즉, **함수를 재사용**할 때 사용하는 Hook이다.

<br>

### useCallback의 기본 구조

```js
const result = useCallback(콜백함수, [의존성 배열])
```

<br>

`useCallback` 또한 `useEffect`, `useMemo`와 동일한 구조를 가지고 있다.

- 첫번째 인자: 콜백함수
- 두번째 인자: 의존성 배열

<br>

- 함수는 의존성 배열이 변경되었을 경우에만 갱신됨
- 의존성 배열의 값이 동일하다면?
  - 해당 함수를 사용하는 컴포넌트가 리렌더링 되더라도 새로운 함수가 생성되지 않음
  - 즉, **컴포넌트가 렌더링 될 때 의존성 배열에 있는 state나 props의 값이 변경되지 않는 한 새로운 함수가 생성되지 않음**

<br>

의존성 배열은 빈 배열로 적용할 수 있는데, state를 사용하지는 않고 변경하기만 했다면 의존성이 없기 때문에 의존성 배열을 추가해 주지 않아도 된다. 하지만 변수로 사용하고 있을 경우, 그 변수를 의존성 배열에 추가해 준다.

<br>

### useCallback이 사용되는 대표적인 경우

1. 이벤트 핸들러 함수 재사용
2. 참조 동일성이 유지되지 않아 생기는 문제를 해결할 때

<br>

`useCallback`은 함수 생성 자체가 오래 걸리는 경우(= 함수 내의 연산이 복잡한 경우) 쓰면 최적화에 도움이 된다. 또한 자식 컴포넌트에 함수를 `props`로 내려주게 되는 경우 `useCallback`을 사용하면 자식 컴포넌트의 리렌더링을 방지할 수 있다.
